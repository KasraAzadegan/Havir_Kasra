گزارش نهایی پروژه وب
کسری آزادگان

گزارش مرحله ۱: بررسی و تست کامل APIها در Swagger

در این مرحله ابتدا مستندات Swagger پروژه بازبینی شد تا تمام Endpointها، مدل‌های داده (Schema)، پارامترهای ورودی و کدهای وضعیت قابل انتظار استخراج شوند. سپس برای هر API یک سناریوی تست استاندارد تعریف شد: سناریوی موفق (Happy Path)، سناریوی ورودی نامعتبر (Validation Error)، سناریوی عدم احراز هویت/دسترسی در صورت وجود Authorizationو سناریوی خطاهای سرور. برای تست عملی، از خود   Swagger UI (Try it out) استفاده شد تا درخواست‌ها با همان Contract تعریف‌شده اجرا شوند و خروجی واقعی با مدل پاسخ مقایسه گردد. علاوه بر این، برای APIهایی که Body دارند، چند نمونه Payload با مقادیر مرزی (مثلاً رشته خالی، طول زیاد، تاریخ نامعتبر و …) ارسال شد تا رفتار سیستم در خطاهای متداول مشخص شود. نتیجه‌ی این مرحله یک جدول مستندسازی Endpointها بود شامل: مسیر، متد، نوع ورودی (Path/Query/Body)، فیلدهای اجباری/اختیاری، نمونه درخواست، نمونه پاسخ، و کدهای وضعیت مشاهده‌شده. این جدول هم برای توسعه فرانت و هم برای دیباگ مرحله‌های بعد مبنا قرار گرفت. 

 





گزارش مرحله ۲: تحلیل صفحات فرانت تست و نگاشت دقیق به APIها با Inspect

برای اینکه مشخص شود هر صفحه دقیقاً چه داده‌ای نیاز دارد، نسخه‌ی تست رابط کاربری (UI test) بررسی شد و با DevTools مرورگر (Inspect) رفتار شبکه‌ای صفحات تحلیل گردید. در تب Network، درخواست‌های XHR/Fetch فیلتر شدند و برای هر صفحه، ترتیب فراخوانی APIها (Call Order)، پارامترهای Query، هدرها خصوصاً (Authorization/Content-Type)، و ساختار پاسخ‌ها ثبت شد. همچنین زمان‌بندی درخواست‌ها بررسی شد تا مشخص شود کدام درخواست‌ها موازی و کدام وابسته به پاسخ قبلی هستند (مثلاً ابتدا دریافت پروفایل/توکن، سپس دریافت لیست‌ها). در تب Console نیز خطاهای احتمالی CORS، خطای parse، یا null/undefined در داده‌های برگشتی کنترل شد. خروجی عملی این مرحله یک ماتریس «Route/صفحه → APIهای مصرفی» بود؛ به‌این صورت که برای هر صفحه مشخص شد کدام APIها باید صدا زده شوند، چه stateهایی لازم است (loading/empty/error)، و داده‌ی برگشتی در کدام بخش UI نمایش داده می‌شود. این نگاشت باعث شد در مرحله پیاده‌سازی لوکال، دقیقاً همان رفتار نسخه‌ی تست را بازتولید کنم. 
(1
Request URL : https://edu.havirkesht.ir/DashBoard
Request Method: GET
Status Code: 304 Not Modified
Remote Address2.: 189.255.173:443 
Referrer Policy: strict-origin-when-cross-origin
(2
Request URL: https://edu.havirkesht.ir/Year-registration
Request Method: GET
Status Code: 304 Not Modified
Remote Address: 2.189.255.173:443
Referrer Policy: strict-origin-when-cross-origin
3)
Request URL: https://edu.havirkesht.ir/SendSmsFarmer
Request Method:GET
Status Code: 304 Not Modified
Remote Address: 2.189.255.173:443
Referrer Policy: strict-origin-when-cross-origin

4)
Request URL: https://edu.havirkesht.ir/FactoryWaste
Request Method: GET
Status Code: 304 Not Modified
Remote Address:2.189.255.173:443
Referrer Policy: strict-origin-when-cross-origin



گزارش مرحله ۳: پیاده‌سازی فرانت در لوکال و اتصال End-to-End به API

در این پروژه، بخش فرانت‌اند سامانه با استفاده از HTML، CSS (Tailwind CSS) و JavaScript خالص (Vanilla JS) پیاده‌سازی شد. تمرکز اصلی روی تطابق کامل رابط کاربری با نسخه اصلی سامانه و رعایت ساختار موردنیاز پروژه بود.
اقدامات انجام‌شده در فرانت‌اند:
•	طراحی و پیاده‌سازی صفحات اصلی شامل:
o	صفحه ورود (Login)
o	داشبورد
o	ثبت استان
o	ثبت سال زراعی
•	استفاده از Tailwind CSS برای طراحی رابط کاربری واکنش‌گرا و هماهنگ با UI اصلی سامانه.
•	پیاده‌سازی منوها، جداول، مدال‌ها و دکمه‌ها مطابق تصاویر و ساختار سایت مرجع.
•	حذف فونت‌های لوکال و استفاده از فونت پیش‌فرض جهت جلوگیری از مشکلات استقرار.
•	یکسان‌سازی ظاهر صفحات ثبت استان و ثبت سال زراعی برای هماهنگی بصری.
اقدامات انجام‌شده در اتصال API:
•	پیاده‌سازی ارتباط با API از طریق fetch در JavaScript.
•	اتصال موفق به API لاگین و مدیریت توکن احراز هویت.
•	اتصال صفحات ثبت استان و ثبت سال زراعی به API مربوطه برای:
o	دریافت لیست داده‌ها
o	ثبت داده جدید
o	حذف داده‌ها
•	مدیریت خطاها و پیام‌های موفقیت با استفاده از SweetAlert جهت نمایش پیام‌های کاربرپسند.
•	رعایت ساختار استاندارد درخواست‌ها طبق مستندات API پروژه.
استقرار (Deploy):
•	آماده‌سازی پروژه برای استقرار روی سرور Liara.
•	حذف وابستگی‌های غیرضروری مانند node_modules از سورس.
•	استقرار پروژه به‌صورت بهینه و اطمینان از عملکرد صحیح فرانت‌اند و ارتباط با API پس از دیپلوی.








گزارش مرحله ۴: مدیریت خطا، پیاده‌سازی پیام‌های کاربرپسند و استانداردسازی Error Handling
در این پروژه، مدیریت خطا با هدف افزایش پایداری سیستم، جلوگیری از بروز رفتارهای نامطلوب و بهبود تجربه کاربری به‌صورت هدفمند پیاده‌سازی شد.
اقدامات انجام‌شده در مدیریت خطا:
•	بررسی پاسخ تمامی درخواست‌های API و تشخیص وضعیت‌های ناموفق (مانند خطاهای ۴xx و ۵xx).
•	مدیریت خطاهای مربوط به عدم دسترسی به سرور، تایم‌اوت یا مشکلات شبکه و اطلاع‌رسانی مناسب به کاربر.
•	استفاده از SweetAlert برای نمایش پیام‌های خطا و موفقیت به‌صورت یکپارچه، خوانا و قابل فهم.
•	انجام اعتبارسنجی اولیه ورودی‌ها در سمت فرانت‌اند جهت جلوگیری از ارسال داده‌های ناقص یا نامعتبر به سرور.
•	نمایش پیام‌های مشخص برای سناریوهای مختلف خطا از جمله:
o	خطای احراز هویت و دسترسی غیرمجاز
o	عدم موفقیت در ثبت یا حذف اطلاعات
o	بروز خطا در دریافت داده‌ها از API
•	جلوگیری از رفرش ناخواسته صفحه و حفظ وضعیت فعلی رابط کاربری در هنگام بروز خطا.
•	نمایش پیام‌های مناسب در صورت موفقیت عملیات جهت اطمینان کاربر از انجام صحیح درخواست‌ها.
با پیاده‌سازی این ساختار، خطاها به‌صورت کنترل‌شده مدیریت شده و کاربر بدون سردرگمی از وضعیت عملیات مطلع می‌شود، در نتیجه تجربه کاربری بهبود یافته و پایداری سامانه افزایش پیدا کرده است.
 





گزارش مرحله ۵: تهیه دامنه و انتقال DNS به ابر آروان به‌همراه تنظیم رکوردها
در این مرحله، مطابق با الزامات پروژه، یک دامنه با پسوند ir. تهیه گردید. پس از ثبت دامنه، به‌منظور مدیریت متمرکز DNS و بهره‌گیری از خدمات شبکه توزیع محتوای ابر آروان، دامنه در پنل ابر آروان اضافه شد.
در ادامه، NameServer‌های دامنه از طریق پنل ثبت‌کننده دامنه به NameServerهای اختصاصی ارائه‌شده توسط ابر آروان تغییر داده شد تا مدیریت کامل DNS از طریق ابر آروان انجام شود. پس از اعمال تغییرات و طی شدن زمان Propagation، دامنه به‌صورت کامل تحت کنترل DNS ابر آروان قرار گرفت.
سپس رکوردهای DNS مورد نیاز برای اتصال دامنه به سرور تنظیم شدند. این تنظیمات شامل:
•	ایجاد A Record برای اشاره دامنه به آدرس IP سرور
•	یا در صورت نیاز، استفاده از CNAME Record برای اتصال دامنه به یک نام میزبان مشخص
به‌منظور اطمینان از صحت پیکربندی DNS و عملکرد صحیح دامنه، پاسخ‌دهی رکوردها با استفاده از ابزارهای بررسی شبکه نظیر nslookup و dig مورد ارزیابی قرار گرفت. نتایج بررسی‌ها نشان‌دهنده‌ی اعمال صحیح تنظیمات و اتصال موفق دامنه به سرور از طریق زیرساخت DNS ابر آروان بود.
 






گزارش مرحله ۶: راه‌اندازی VPS لینوکسی و پیکربندی Nginx برای سروینگ فرانت

در این مرحله برای استقرار فرانت‌اند از پلتفرم لیارا استفاده کردم. ابتدا در سایت لیارا ثبت‌نام و وارد بخش «پلتفرم» شدم و یک برنامه جدید ایجاد کردم. چون پروژه با HTML/CSS/JS پیاده‌سازی شده بود، نوع برنامه را روی حالت Static قرار دادم. سپس در قسمت شناسه برنامه، یک نام یکتا (ترجیحاً هم‌نام با دامنه) انتخاب کردم و برای ایزوله‌سازی ارتباطات، شبکه خصوصی را نیز ایجاد/فعال کردم.
بعد از ساخت برنامه، فایل Zip شامل سورس فرانت را در بخش Deploy آپلود کردم تا فرآیند انتشار انجام شود. پس از اتمام آپلود، لیارا عملیات استقرار را انجام داد و برنامه روی سرورهای آن فعال شد؛ در این مرحله با مشاهده وضعیت Deploy و بررسی خروجی برنامه مطمئن شدم سایت از طریق آدرس پیش‌فرض لیارا بدون خطا لود می‌شود.
در ادامه برای اتصال دامنه، وارد بخش DNS/دامنه‌ها در لیارا شدم و دامنه اصلی را اضافه کردم. سپس برای اینکه دامنه به زیرساخت لیارا متصل شود، به پنل ایرنیک (جایی که دامنه را تهیه کرده بودم) مراجعه کردم و NameServerهای قبلی را حذف کردم و NameServerهای ارائه‌شده توسط لیارا را قرار دادم. بعد از ثبت تغییرات و گذشت زمان لازم برای انتشار DNS، دامنه فعال شد و در پنل لیارا مشاهده شد که رکوردهای مربوط به دامنه به صورت خودکار شناسایی/ایجاد شده‌اند.
در نهایت، برای مدیریت بهتر DNS و تنظیمات، رکوردهای موردنیاز دامنه اصلی را در اروان کلاد  دقیقاً طبق مقادیری که ارائه شده بود اضافه کردم و سپس رکوردهای مربوط به زیردامنه www را نیز تنظیم کردم تا دامنه www هم به درستی به نسخه اصلی سایت متصل و قابل استفاده باشد.
 





گزارش مرحله ۷: مدیریت سورس پروژه با GitHub و استقرار کد روی سرور

۱. بررسی نصب Git و تنظیم مشخصات کاربری (مرحله اولیه)
ابتدا بررسی شد که ابزار Git روی سیستم نصب باشد. سپس برای ثبت صحیح تاریخچه commitها، مشخصات کاربری تنظیم گردید:
git --version
git config --global user.name "Kasra Azadegan"
git config --global user.email "kasra.azadegan@gmail.com"
این تنظیمات تنها یک‌بار انجام می‌شوند و برای تمام پروژه‌ها معتبر هستند.

۲. آماده‌سازی پروژه برای مدیریت نسخه
پروژه در محیط VS Code باز شد و فایل .gitignore ایجاد گردید تا فایل‌ها و پوشه‌های غیرضروری وارد مخزن نشوند.
مواردی مانند:
•	node_modules
•	پوشه‌های build یا dist
•	فایل‌های موقتی و تنظیمات محلی
از مخزن GitHub حذف شدند تا ریپازیتوری سبک، تمیز و حرفه‌ای باقی بماند.

۳. فعال‌سازی Git و ثبت نسخه اولیه پروژه
در پوشه پروژه، Git مقداردهی اولیه شد و اولین نسخه به‌عنوان نقطه شروع پروژه ثبت گردید:
git init
git add .
git commit -m "Initial project structure"
git branch -M main

۴. ایجاد مخزن پروژه در GitHub
در وب‌سایت GitHub، یک ریپازیتوری جدید با نام زیر ایجاد شد:
https://github.com/KasraAzadegan/Havir_Kasra
این مخزن به‌عنوان مرجع اصلی سورس کد پروژه در نظر گرفته شد.











۵. اتصال پروژه محلی به مخزن GitHub (Remote)
پس از ساخت ریپو، آدرس آن به‌عنوان remote به پروژه لوکال اضافه شد:
git remote add origin https://github.com/KasraAzadegan/Havir_Kasra.git
برای اطمینان از صحت اتصال:
git remote -v
در صورت نیاز، آدرس remote اصلاح شد:
git remote set-url origin https://github.com/KasraAzadegan/Havir_Kasra.git

۶. ارسال نسخه اولیه پروژه به GitHub
در این مرحله، سورس اولیه پروژه روی شاخه main در GitHub بارگذاری شد:
git push --set-upstream origin main

۷. همگام‌سازی در صورت وجود commit اولیه در GitHub
در صورتی که ریپازیتوری GitHub از قبل شامل commit پیش‌فرض (مانند README) بود و عملیات push با خطا مواجه شد، ابتدا مخزن همگام‌سازی شد:
git pull --rebase origin main
git push --set-upstream origin main

۸. روند استاندارد ثبت و ارسال تغییرات بعدی
پس از هر تغییر در سورس پروژه، مراحل زیر به‌صورت منظم انجام شد:
git add -A
git commit -m "Meaningful commit message"
git push
پیام commitها کوتاه، شفاف و بیانگر نوع تغییرات انتخاب شدند تا تاریخچه پروژه خوانا و قابل پیگیری باشد.

۹. آماده‌سازی برای استقرار روی سرور
برای استقرار کد روی سرور:
•	دسترسی امن به GitHub از طریق SSH Key روی سرور تنظیم شد تا clone و pull بدون نیاز به رمز عبور انجام شود.
•	مخزن پروژه روی سرور clone گردید.
•	مسیر deploy مشخص شد.
•	فرآیند build تعریف شد (نصب dependencyها، اجرای build و انتقال خروجی به مسیر سرویس Nginx).
•	نسخه Node.js و ابزارهای موردنیاز روی سرور با محیط توسعه هم‌راستا شد تا از خطاهای محیطی جلوگیری شود.

 


گزارش مرحله ۸: فعال‌سازی SSL و تنظیم دامنه/زیر دامنه روی لیارا

بعد از اینکه برنامه روی لیارا Deploy و دامنه به آن متصل شد، در پنل برنامه وارد بخش دامنه‌ها و SSL شدم. در همین قسمت وضعیت گواهی SSL قابل مشاهده است و با فعال‌سازی آن، سایت به صورت امن روی HTTPS در دسترس قرار گرفت. پس از فعال‌سازی، صحت اجرا را با باز کردن سایت از طریق https و بررسی قفل امنیتی مرورگر کنترل کردم.
در صورتی که نیاز به زیر دامنه www باشد، از همان بخش دامنه‌ها گزینه مربوط به www را فعال کردم. لیارا رکوردهای DNS موردنیاز را نمایش می‌دهد و معمولاً اتصال آن به صورت خودکار انجام می‌شود. بعد از اینکه www نیز به برنامه متصل شد، برای این زیر دامنه هم گواهی SSL فعال/دریافت شد تا هر دو آدرس دامنه اصلی و www روی HTTPS بدون خطا اجرا شوند.
در نهایت برای جلوگیری از مشکلات سئو و جلوگیری از محتوای تکراری (Duplicate Content)، در تنظیمات دامنه، زیر دامنه/دامنه پیش‌فرض لیارا را غیرفعال کردم تا فقط نسخه اصلی سایت از طریق دامنه اصلی و در صورت نیاز www در دسترس باشد. بعد از انجام این تنظیمات، با دامنه شخصی خودم بدون هشدار امنیتی می‌توانم به سایت هاویرکِشت متصل شوم.

 





گزارش مرحله ۹: پیاده‌سازی CI/CD برای استقرار خودکار تغییرات

در این مرحله برای اینکه انتشار پروژه دستی نباشد، از قابلیت CI/CD استفاده کردم. CI (Continuous Integration) باعث می‌شود با هر بار ارسال تغییرات به مخزن، روند یکپارچه‌سازی و بررسی کد منظم‌تر انجام شود و CD (Continuous Delivery/Deployment) کمک می‌کند همان تغییرات سریع و بدون دخالت دستی روی سرور (لیارا) Deploy شود. یعنی هر بار که روی GitHub push انجام می‌دهم، یک pipeline اجرا می‌شود و نسخه جدید پروژه به صورت خودکار روی لیارا به‌روزرسانی می‌شود.
برای فعال‌سازی این روند، فایل workflow پیشنهادی لیارا را داخل پروژه قرار دادم. مسیر فایل را دقیقاً به این صورت ساختم:
.github/workflows/liara.yaml
این فایل را در ریشه اصلی پروژه اضافه کردم تا GitHub Actions آن را شناسایی کند. سپس داخل فایل، مقدار APP_NAME را با شناسه دقیق برنامه‌ای که در لیارا ساخته بودم جایگزین کردم تا workflow بداند خروجی را برای کدام اپلیکیشن Deploy کند.
در مرحله بعد برای اینکه GitHub اجازه دسترسی امن به لیارا را داشته باشد، توکن API لیارا را به صورت Secret در تنظیمات ریپازیتوری ذخیره کردم (نه داخل کد). برای این کار وارد GitHub شدم و از مسیر Settings → Secrets and variables → Actions گزینه New repository secret را زدم. نام Secret را LIARA_API_TOKEN گذاشتم و مقدار آن را از بخش «کلید دسترسی API» در پنل لیارا کپی و در قسمت Value وارد کردم و ذخیره کردم. این کار باعث می‌شود توکن در pipeline استفاده شود ولی در ریپو قابل مشاهده نباشد.
در پایان، فایل liara.yaml را commit و push کردم. بعد از push، به صورت خودکار یک workflow در تب Actions ریپازیتوری اجرا شد و مراحل build/deploy را نشان داد. با مشاهده لاگ‌های همان بخش، مطمئن شدم pipeline بدون خطا انجام شده و نسخه جدید پروژه روی لیارا Deploy شده است. از این به بعد هم هر تغییر جدیدی که push کنم، همین روند به‌صورت اتوماتیک تکرار می‌شود و پروژه همیشه به‌روز می‌ماند.
 
